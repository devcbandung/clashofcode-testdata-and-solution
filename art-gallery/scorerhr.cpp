
// Start of BODY
/**
 * TestStruct members::
 *  testcase_id                   [size_t] ID of the test-case
 *  testcase_input_path           [string] File path to test-case input
 *  testcase_output_path          [string] File path to test-case output generated by the problem solver
 *  testcase_expected_output_path [string] File path to test-case expected output to be matched with
 *  testcase_error_path           [string] File path to test-case STDERR
 *  metadata_file_paths           [vector<string>] File paths to Question metadata (Extra files usually used for defining traning sets)
 *  submission_code_path          [string] File path to submission source code
 *  submission_language           [string] Language token of submission
 *  testcase_result               [bool] Set to true if test-case output matches test-case expected output. Matching is done line by line
 *  testcase_signal               [size_t] Exit code of the test-case process
 *  testcase_time                 [float] Time taken by the test-case process in seconds
 *  testcase_memory               [size_t] Peak memory of the test-case process determined in bytes
 *  data                          [string] <Future use>
 *
 *
 *  ResultStruct::
 *    result      [bool]  Assign test-case result. true determines success. false determines failure
 *    score       [float] Assign test-case score. Normalized between 0 to 1
 *    message     [string] Assign test-case message. This message is visible to the problem solver
**/

void wa(ResultStruct &r_obj, const string& message) {
  r_obj.result = false;
  r_obj.score = 0.0f;
  r_obj.message = message;
}

void run_custom_checker(const TestStruct t_obj,
                        ResultStruct &r_obj) {
    //Don't print anything to STDOUT in this function
    //Enter your custom checker scoring logic here
  ifstream tc_in(t_obj.testcase_input_path, ios_base::in);
  ifstream tc_out(t_obj.testcase_expected_output_path, ios_base::in);
  ifstream con_out(t_obj.testcase_output_path, ios_base::in);

  auto close = [&]() {
    tc_in.close();
    tc_out.close();
    con_out.close();
  };
  auto waAndClose = [&]() {
    wa(r_obj, "Wrong Answer");
    close();
  };

  // AC by default
  r_obj.result = true;
  r_obj.score = 1.0f;
  r_obj.message = "Success";

  // read output
  double nans = 0;
  tc_out >> nans;

  // read contestant output
  double cans = 0;
  if (!(con_out >> cans)) {
    return waAndClose();
  }

  if (fabs(cans-nans)/nans > 1e-6) {
    return waAndClose();
  }

  close();
}
// End of BODY
